<template>
	<view class="container">
		<!-- 顶部数据区域 -->
		<view class="data-section">
			<text class="section-title">我的数据</text>
			<view class="data-list">
				<view class="data-list-item">
					<text class="data-list-label">总里程</text>
					<text class="data-list-value">{{totalDistance}} km</text>
				</view>
				<view class="data-list-item">
					<text class="data-list-label">最快速度</text>
					<text class="data-list-value">{{maxSpeed}} km/h</text>
				</view>
				<view class="data-list-item">
					<text class="data-list-label">最长时间</text>
					<text class="data-list-value">{{maxTime}} h</text>
				</view>
			</view>
		</view>

		<!-- 中间历史骑行数据区域 -->
		<view class="history-section">
			<text class="section-title">历史骑行数据</text>
			<view class="history-list">
				<view class="history-item" v-for="(item, index) in historyData" :key="index">
					<view class="history-date">
						<text class="date-text">{{item.date}}</text>
					</view>
					<view class="history-details">
						<text class="time-text">{{item.time}}</text>
						<text class="location-text">{{item.location}}</text>
					</view>
				</view>
			</view>
		</view>

		<!-- 底部设备区域 -->
		<view class="device-section">
			<text class="section-title">我的设备</text>
			<view class="device-container">
				<view class="device-box" @click="toggleBluetooth">
					<text class="device-name">{{deviceName}}</text>
					<text class="device-status">{{deviceStatus}}</text>
					<text class="search-hint" v-if="isSearching">搜索中...</text>
				</view>
			</view>
			<!-- 设备信息显示区域 -->
			<view class="device-info-section" v-if="deviceInfo.show">
				<view class="device-info-item">
					<text class="device-info-label">设备名称:</text>
					<text class="device-info-value">{{deviceInfo.name || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">连接状态:</text>
					<text class="device-info-value" :class="deviceInfo.connected ? 'connected' : 'disconnected'">
						{{deviceInfo.connected ? '已连接' : '未连接'}}
					</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">型号:</text>
					<text class="device-info-value">{{deviceInfo.model || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">序列号:</text>
					<text class="device-info-value">{{deviceInfo.serialNumber || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">固件版本:</text>
					<text class="device-info-value">{{deviceInfo.firmwareVersion || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">硬件版本:</text>
					<text class="device-info-value">{{deviceInfo.hardwareVersion || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">软件版本:</text>
					<text class="device-info-value">{{deviceInfo.softwareVersion || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">制造商:</text>
					<text class="device-info-value">{{deviceInfo.manufacturer || '未知'}}</text>
				</view>
				<view class="device-info-item">
					<text class="device-info-label">电池电量:</text>
					<text class="device-info-value battery">{{deviceInfo.batteryLevel || '未知'}}</text>
				</view>
			</view>
			<!-- 设备列表 -->
			<view class="device-list" v-if="discoveredDevices.length > 0">
				<view class="device-list-item" v-for="(device, index) in discoveredDevices" :key="index"
					@click="connectDevice(device)">
					<text class="device-item-name">{{device.name || '未知设备'}}</text>
					<text class="device-item-signal">信号强度: {{device.RSSI}}dBm</text>
					<view class="device-item-actions">
						<view class="action-button" @click.stop="disconnectDevice(device)" v-if="device.connected">
							<text class="action-text">断开</text>
						</view>
						<view class="action-button" @click.stop="removeDevice(device)">
							<text class="action-text">移除</text>
						</view>
					</view>
				</view>
			</view>
		</view>



	</view>
</template>

<script>export default {
		data() {
			return {
				// 数据展示
				totalDistance: 128.5,
				maxSpeed: 35.2,
				maxTime: 4.5,
				// 历史骑行数据
				historyData: [
					{
						date: '2023-06-15',
						time: '14:30 - 16:45',
						location: '城市公园'
					},
					{
						date: '2023-06-10',
						time: '09:15 - 11:30',
						location: '湖边绿道'
					},
					{
						date: '2023-06-05',
						time: '16:00 - 18:20',
						location: '山地赛道'
					},
					{
						date: '2023-05-28',
						time: '10:30 - 13:15',
						location: '滨江路'
					}
				],
				// 设备信息
				deviceName: '智能骑行传感器 A1',
				deviceStatus: '未连接',
				// 蓝牙相关数据
				isSearching: false,
				discoveredDevices: [],
				connectedDeviceId: '',
				bluetoothEnabled: false,
				searchTimer: null,
				// 设备详细信息
			deviceInfo: {
				show: false,
				model: '',
				serialNumber: '',
				firmwareVersion: '',
				hardwareVersion: '',
				softwareVersion: '',
				manufacturer: '',
				batteryLevel: '',
				name: '',
				connected: false
			},
			// 蓝牙服务和特征值存储
			bleServices: {},
			bleCharacteristics: {},
			// 监听器状态
			characteristicListenerSet: false,
			// 连接状态监控
			connectionMonitorInterval: null,

			}
		},
		onLoad() {
			// 页面加载时只初始化数据，不初始化蓝牙
			this.initData();
		},
		onShow() {
			// 页面显示时直接初始化蓝牙并开始搜索设备
			console.log('页面显示，开始搜索设备');
			this.initBluetooth();
			// 延迟一下确保蓝牙初始化完成，然后开始搜索
			setTimeout(() => {
				this.searchDevices();
			}, 500);
		},
		onUnload() {
			console.log('页面卸载');
			// 停止搜索
			this.stopSearchDevices();
			// 停止连接监控，但不主动断开设备连接，保持连接稳定性
			this.stopConnectionMonitor();
		},
		methods: {
			// 初始化数据
			initData() {
				// 这里可以从本地存储或服务器获取数据
				console.log('我的页面数据初始化');
			},

			// 初始化蓝牙适配器
		initBluetooth() {
			// 保存当前组件实例的this引用
			const that = this;
			console.log('初始化蓝牙适配器');

			// 监听蓝牙状态变化
			uni.onBluetoothAdapterStateChange((res) => {
				if (!res.available) {
					that.deviceStatus = '蓝牙不可用';
					that.bluetoothEnabled = false;
				} else {
					that.bluetoothEnabled = true;
					that.deviceStatus = '蓝牙已就绪';
					// 蓝牙可用时自动搜索设备
					if (res.discovering) {
						// 如果已经在搜索中，则不重复搜索
						return;
					}
					// 延迟2秒开始搜索，确保蓝牙完全就绪
					setTimeout(() => {
						that.searchDevices();
					}, 2000);
				}
			});

			// 检查蓝牙是否可用
			uni.getBluetoothAdapterState({
				success: (res) => {
					console.log('getBluetoothAdapterState', res);
					if (!res.available) {
						that.deviceStatus = '蓝牙不可用';
						that.bluetoothEnabled = false;
					} else {
						that.bluetoothEnabled = true;
						that.deviceStatus = '蓝牙已就绪';
						// 蓝牙可用时自动搜索设备
						if (!res.discovering) {
							// 延迟2秒开始搜索，确保蓝牙完全就绪
							setTimeout(() => {
								that.searchDevices();
							}, 2000);
						}
					}
				},
				fail: (err) => {
					console.error('获取蓝牙适配器状态失败', err);
					that.deviceStatus = '蓝牙不可用';
					that.bluetoothEnabled = false;
				}
			});
		},


			// 切换蓝牙开关
		toggleBluetooth() {
		const that = this;
		if (that.bluetoothEnabled) {
			that.closeBluetooth();
		} else {
			// 第一次点击时才初始化蓝牙适配器
			that.initBluetooth();
			that.openBluetooth();
		}
	},



			// 打开蓝牙
		openBluetooth() {
			// 保存当前组件实例的this引用
			const that = this;
			console.log('打开蓝牙');
			console.log(uni.getSystemInfoSync().platform);
			if (uni.getSystemInfoSync().platform === 'android') {
				// Android平台
				uni.openBluetoothAdapter({
					success: (res) => {
						console.log('openBluetoothAdapter success', res);
						that.bluetoothEnabled = true;
						that.deviceStatus = '蓝牙已开启';
						// 自动开始搜索设备
						that.searchDevices();
					},
					fail: (res) => {
						if (res.errCode === 10001) {
							uni.onBluetoothAdapterStateChange((res) => {
								console.log('onBluetoothAdapterStateChange', res);
								if (res.available) {
									that.bluetoothEnabled = true;
									that.deviceStatus = '蓝牙已开启';
									// 自动开始搜索设备
									that.searchDevices();
								}
							});
						}
						that.deviceStatus = '蓝牙开启失败';
					}
				});
			} else if (uni.getSystemInfoSync().platform === 'ios') {
				// iOS平台
				uni.openBluetoothAdapter({
					success: (res) => {
						console.log('openBluetoothAdapter success', res);
						that.bluetoothEnabled = true;
						that.deviceStatus = '蓝牙已开启';
						// 自动开始搜索设备
						that.searchDevices();
					},
					fail: (res) => {
						that.deviceStatus = '蓝牙开启失败';
					}
				});
			}
		},

			// 关闭蓝牙
		closeBluetooth() {
			// 保存当前组件实例的this引用
			const that = this;
			console.log('关闭蓝牙');
			uni.closeBluetoothAdapter({
				success: (res) => {
					console.log('关闭蓝牙适配器成功', res);
					that.bluetoothEnabled = false;
					that.deviceStatus = '蓝牙已关闭';
					// 断开所有连接的设备
					that.disconnectAllDevices();
					// 清空设备列表
					that.discoveredDevices = [];
				},
				fail: (err) => {
					console.error('关闭蓝牙适配器失败', err);
				}
			});
		},

			// 判断数组中是否包含某个元素
			inArray(arr, key, val) {
				for (let i = 0; i < arr.length; i++) {
					if (arr[i][key] === val) {
						return i;
					}
				}
				return -1;
			},

			// 搜索设备
		searchDevices() {
			// 保存当前组件实例的this引用，确保在所有回调中都能正确访问
			const that = this;

			if (!that.bluetoothEnabled) {
				uni.showToast({
					title: '请先开启蓝牙',
					icon: 'none'
				});
				return;
			}

			if (that.isSearching) {
				console.log('正在搜索中，请稍候...');
				return;
			}

			console.log('开始搜索蓝牙设备');
			that.isSearching = true;
			that.deviceStatus = '搜索中...';
			that.discoveredDevices = [];
			that.deviceInfo.show = false;

			// 清除之前可能存在的搜索定时器和超时定时器
			if (that.searchTimer) {
				clearInterval(that.searchTimer);
				that.searchTimer = null;
			}
			if (that.searchTimeoutTimer) {
				clearTimeout(that.searchTimeoutTimer);
				that.searchTimeoutTimer = null;
			}

			// 用于控制日志输出频率的变量
			that.lastLogTime = {};
			that.logInterval = 2000; // 日志输出间隔，单位毫秒

			// 使用uni-app的蓝牙API
			uni.openBluetoothAdapter({
				success: (res) => {
					console.log('蓝牙适配器已打开', res);

					// 开始搜索设备，指定设备发现服务UUID
					uni.startBluetoothDevicesDiscovery({
						allowDuplicatesKey: true,  // 添加这一行，允许重复上报设备
						// services: ['0xADB401C0B1C6-11ED-AFA1-0242AC120002'], // 设备发现服务UUID
						success: (res) => {
							console.log('开始搜索设备', res);

							// 监听发现新设备事件
							uni.onBluetoothDeviceFound((res) => {
								// 只有在未连接设备时才处理新设备和输出日志
								if (that.connectedDeviceId) {
									return;
								}
								
								res.devices.forEach(device => {
									if (!device.name && !device.localName) {
										return;
									}

									// 获取当前时间戳
									const now = Date.now();
									const deviceId = device.deviceId;
									
									// 检查是否应该输出日志（每2秒只输出一次相同设备的日志）
									if (!that.lastLogTime[deviceId] || (now - that.lastLogTime[deviceId] >= that.logInterval)) {
										// 更新最后输出日志的时间
										that.lastLogTime[deviceId] = now;
										
										// 只输出必要的日志信息
										console.log('发现设备:', device.name, 'ID:', deviceId);
									}

									const foundDevices = that.discoveredDevices;
									const idx = that.inArray(foundDevices, 'deviceId', deviceId);
									
									if (idx === -1) {
										// 过滤设备，只显示名称中包含"RideHDD"的设备
										if (device.name && device.name.includes('RideHDD')) {
											// 只在添加新设备时输出详细日志
											console.log('添加新设备:', device.name);
											const newDevice = {
												deviceId: deviceId,
												name: device.name,
												RSSI: device.RSSI,
												connected: false
											};
											that.discoveredDevices.push(newDevice);
											
											// 自动连接设备
											console.log('尝试连接设备:', device.name);
											that.connectDevice(newDevice);
										}
									} else {
										// 更新已存在的设备信息，但不输出过多日志
										that.discoveredDevices[idx] = {
											...that.discoveredDevices[idx],
											RSSI: device.RSSI,
											name: device.name || that.discoveredDevices[idx].name
										};
										
										// 检查设备是否已连接，如果未连接则尝试连接（每2秒只尝试一次）
										if (!that.discoveredDevices[idx].connected && !that.connectedDeviceId) {
											if (!that.lastConnectAttempt || (now - that.lastConnectAttempt >= that.logInterval)) {
												that.lastConnectAttempt = now;
												console.log('尝试重新连接设备:', device.name);
												that.connectDevice(that.discoveredDevices[idx]);
											}
										}
									}
								});
							});
						},
						fail: (err) => {
							console.error('搜索设备失败', err);
							that.isSearching = false;
							that.deviceStatus = '搜索失败';
						}
					});

					// 设置定时器，每2秒检查一次是否需要继续搜索
					that.searchTimer = setInterval(() => {
						if (that.isSearching && !that.connectedDeviceId) {
							// 减少定时器中的日志输出
							// 先检查蓝牙适配器状态，避免在未初始化时调用API导致错误
							uni.getBluetoothAdapterState({
								success: (res) => {
									// 只有当蓝牙适配器可用时，才执行搜索操作
									if (res.available) {
										// 只有当没有在搜索时才重新开始搜索，避免频繁停止和启动
										if (!res.discovering) {
											// 如果没有在搜索，直接开始搜索
											uni.startBluetoothDevicesDiscovery({
												allowDuplicatesKey: true,
												success: (res) => {
													// 减少启动搜索时的日志
												},
												fail: (err) => {
													console.error('搜索设备失败', err);
												}
											});
										}
									}
								},
								fail: (err) => {
									console.error('获取蓝牙适配器状态失败', err);
									// 如果获取状态失败，可能是蓝牙已关闭，更新UI状态
									that.isSearching = false;
									if (that.searchTimer) {
										clearInterval(that.searchTimer);
										that.searchTimer = null;
									}
								}
							});
						} else if (that.connectedDeviceId) {
							// 如果已经连接了设备，停止搜索
							console.log('已连接设备，停止搜索');
							that.stopSearchDevices();
						}
					}, 2000);
					
					// 添加搜索超时机制，30秒后自动停止搜索
					that.searchTimeoutTimer = setTimeout(() => {
						if (that.isSearching && !that.connectedDeviceId) {
							console.log('搜索超时，自动停止搜索');
							that.stopSearchDevices();
							that.deviceStatus = '搜索超时，请手动重试';
						}
					}, 30000);
				},
				fail: (err) => {
					console.error('打开蓝牙适配器失败', err);
					that.isSearching = false;
					that.deviceStatus = '蓝牙开启失败';
					// 清除定时器
					if (that.searchTimer) {
						clearInterval(that.searchTimer);
						that.searchTimer = null;
					}
				}
			});
		},

			// 停止搜索设备
		stopSearchDevices() {
			// 保存当前组件实例的this引用
			const that = this;
			console.log('停止搜索蓝牙设备');
			// 清除搜索定时器和超时定时器
			if (that.searchTimer) {
				clearInterval(that.searchTimer);
				that.searchTimer = null;
			}
			if (that.searchTimeoutTimer) {
				clearTimeout(that.searchTimeoutTimer);
				that.searchTimeoutTimer = null;
			}
			
			// 清除日志输出控制变量，确保设备连接后完全停止日志输出和刷新
			that.lastLogTime = {};
			that.lastConnectAttempt = null;
			that.logInterval = null;
				
				// 先检查蓝牙适配器状态，避免在未初始化时调用停止搜索导致错误
				uni.getBluetoothAdapterState({
					success: (res) => {
						// 只有当蓝牙适配器可用且正在搜索时，才调用停止搜索
						if (res.available && res.discovering) {
							uni.stopBluetoothDevicesDiscovery({
								success: (res) => {
									console.log('停止搜索设备成功', res);
								},
								fail: (err) => {
									console.error('停止搜索设备失败', err);
								}
							});
						}
						// 无论停止搜索是否成功，都更新UI状态
						that.isSearching = false;
						if (that.discoveredDevices.length === 0) {
							that.deviceStatus = '未找到设备';
						} else {
							that.deviceStatus = '找到 ' + that.discoveredDevices.length + ' 个设备';
						}
					},
					fail: (err) => {
						console.error('获取蓝牙适配器状态失败', err);
						// 即使获取状态失败，也更新UI状态
						that.isSearching = false;
					}
				});
			},

			// 检查是否有已连接的设备
checkConnectedDevice() {
	console.log('检查设备连接状态');
	const savedDeviceId = uni.getStorageSync('connectedDeviceId');
	const savedDeviceName = uni.getStorageSync('connectedDeviceName');

	if (savedDeviceId) {
		this.deviceStatus = '检查设备连接状态...';
		
		// 立即更新UI，显示正在检查状态
		this.$forceUpdate();
		
		// 首先确保蓝牙适配器已初始化
		uni.openBluetoothAdapter({
			success: () => {
				console.log('蓝牙适配器已开启');
				// 检查设备是否仍然连接
				this.checkDeviceConnection(savedDeviceId, savedDeviceName);
				this.bluetoothEnabled = true;
			},
			fail: (err) => {
				console.error('蓝牙适配器未开启，尝试初始化', err);
				// 如果蓝牙适配器未开启，先初始化蓝牙
				this.initBluetooth();
				this.bluetoothEnabled = false;
				// 延迟后再次检查连接状态
				setTimeout(() => {
					this.checkDeviceConnection(savedDeviceId, savedDeviceName);
				}, 1000);
			}
		});
	} else {
		console.log('没有保存的连接设备');
		this.deviceStatus = '未连接';
	}
},

// 检查设备连接状态的核心方法
checkDeviceConnection(savedDeviceId, savedDeviceName) {
	console.log('检查设备连接状态 - 核心方法', savedDeviceId);
	
	// 检查设备是否仍然连接
	uni.getConnectedBluetoothDevices({
		success: (res) => {
			console.log('获取已连接设备列表', res);
			const isStillConnected = res.devices.some(device => device.deviceId === savedDeviceId);
			
			if (isStillConnected) {
				console.log('设备仍然保持连接');
				this.updateConnectedState(savedDeviceId, savedDeviceName);
			} else {
				console.log('设备连接已断开');
				this.clearConnectedDeviceStorage();
				this.deviceStatus = '未连接';
				// 强制更新UI
				this.$forceUpdate();
			}
		},
		fail: (err) => {
			console.error('获取已连接设备列表失败', err);
			// 即使获取设备列表失败，也尝试检查设备服务，可能设备还在连接
			this.updateConnectedState(savedDeviceId, savedDeviceName);
			
			// 尝试获取设备服务，验证连接是否有效
			setTimeout(() => {
				this.verifyConnectionStatus();
			}, 500);
		}
	});
},

// 更新已连接状态的UI和逻辑
updateConnectedState(savedDeviceId, savedDeviceName) {
	console.log('更新已连接状态', savedDeviceId);
	
	// 更新UI状态
	this.connectedDeviceId = savedDeviceId;
	this.deviceName = savedDeviceName || '未知设备';
	this.deviceStatus = '已连接';
	this.deviceInfo.show = true;
	this.deviceInfo.connected = true;
	this.deviceInfo.name = savedDeviceName || '未知设备';
	
	// 重置监听器状态并立即设置监听器
	this.characteristicListenerSet = false;
	this.setupCharacteristicListener();

	// 延迟重新获取设备服务和特征值，确保连接稳定
	setTimeout(() => {
		this.getBLEDeviceServices(savedDeviceId);
	}, 1000);

	// 启动连接监控
	this.startConnectionMonitor();
	
	// 强制更新UI，确保用户看到连接状态
	this.$forceUpdate();
}
	},

		// 启动连接监控
		startConnectionMonitor() {
			// 清除现有的监控
			this.stopConnectionMonitor();

			// 设置新的监控，每30秒检查一次连接状态
			this.connectionMonitorInterval = setInterval(() => {
				if (this.connectedDeviceId) {
					this.verifyConnectionStatus();
				}
			}, 30000); // 30秒检查一次
		},

		// 停止连接监控
		stopConnectionMonitor() {
			if (this.connectionMonitorInterval) {
				clearInterval(this.connectionMonitorInterval);
				this.connectionMonitorInterval = null;
			}
		},

		// 验证连接状态
		verifyConnectionStatus() {
			console.log('验证设备连接状态');
			if (!this.connectedDeviceId) return;

			// 尝试获取设备服务来验证连接是否仍然有效
			uni.getBLEDeviceServices({
				deviceId: this.connectedDeviceId,
				success: (res) => {
					console.log('连接状态验证成功，设备仍然在线');
					// 连接正常，无需操作
				},
				fail: (err) => {
					console.error('连接状态验证失败，设备可能已断开', err);
					// 连接已断开，更新状态
					this.handleUnexpectedDisconnect();
				}
			});
		},

		// 处理意外断开连接
		handleUnexpectedDisconnect() {
			console.log('处理意外断开连接');
			// 停止连接监控
			this.stopConnectionMonitor();

			// 更新UI状态
			this.connectedDeviceId = '';
			this.deviceName = '智能骑行传感器 A1';
			this.deviceStatus = '连接丢失';

			// 更新设备信息显示
			if (this.deviceInfo.show) {
				this.deviceInfo.connected = false;
				// 保留设备信息，但显示连接丢失状态
			}

			// 清除本地存储
			this.clearConnectedDeviceStorage();

			// 移除监听器
			uni.offBLECharacteristicValueChange();
			this.characteristicListenerSet = false;

			// 显示连接丢失提示
			uni.showToast({
				title: '设备连接已丢失',
				icon: 'none'
			});
		},
			
			// 清除本地存储的连接状态
			clearConnectedDeviceStorage() {
				uni.removeStorageSync('connectedDeviceId');
				uni.removeStorageSync('connectedDeviceName');
			},

			// 连接设备
		connectDevice(device) {
			console.log('连接设备', device);
			if (!this.bluetoothEnabled) {
				uni.showToast({
					title: '请先开启蓝牙',
					icon: 'none'
				});
				return;
			}

			// 如果已经有连接的设备，先断开
			if (this.connectedDeviceId && this.connectedDeviceId !== device.deviceId) {
				this.disconnectDevice({deviceId: this.connectedDeviceId});
			}

			this.deviceStatus = '连接中...';
			// 强制更新UI，让用户看到连接状态变化
			this.$forceUpdate();

			// 使用uni-app的蓝牙API连接设备
			uni.createBLEConnection({
				deviceId: device.deviceId,
				success: (res) => {
					console.log('连接设备成功', res);

					// 立即更新设备状态，不等待后续操作
					device.connected = true;
					this.connectedDeviceId = device.deviceId;
					this.deviceName = device.name || '未知设备';
					this.deviceStatus = '已连接';
					this.deviceInfo.show = true;
					this.deviceInfo.connected = true;
					this.deviceInfo.name = device.name || '未知设备';

					// 立即设置监听器，确保不错过任何数据
					this.setupCharacteristicListener();

					// 停止搜索
					this.stopSearchDevices();

					// 保存连接状态到本地存储
					uni.setStorageSync('connectedDeviceId', device.deviceId);
					uni.setStorageSync('connectedDeviceName', device.name || '未知设备');

					// 延迟获取设备服务，确保连接稳定
					setTimeout(() => {
						this.getBLEDeviceServices(device.deviceId);
					}, 1000); // 增加延迟时间到1秒，确保连接完全稳定

					// 启动连接监控
					this.startConnectionMonitor();

					// 强制更新UI，确保用户看到连接成功状态
					this.$forceUpdate();
					
					uni.showToast({
						title: '连接成功',
						icon: 'success'
					});
				},
				fail: (err) => {
					console.error('连接设备失败', err);
					this.deviceStatus = '连接失败';
					// 清除存储的连接状态
					this.clearConnectedDeviceStorage();
					// 强制更新UI
					this.$forceUpdate();

					uni.showToast({
						title: '连接失败',
						icon: 'none'
					});
				}
			});
		},

			// 断开设备连接
		disconnectDevice(device) {
			console.log('断开设备连接', device);
			const that = this;

			// 使用uni-app的蓝牙API断开连接
			uni.closeBLEConnection({
				deviceId: device.deviceId,
				success: (res) => {
					console.log('断开设备连接成功', res);

					// 更新设备状态
					device.connected = false;
					if (that.connectedDeviceId === device.deviceId) {
						that.connectedDeviceId = '';
						that.deviceName = '智能骑行传感器 A1';
						that.deviceStatus = '已断开';
						// 清空设备信息并隐藏显示
						that.deviceInfo.show = false;
						that.deviceInfo.connected = false;
						that.deviceInfo.name = '';
						that.deviceInfo.model = '';
						that.deviceInfo.serialNumber = '';
						that.deviceInfo.firmwareVersion = '';
						that.deviceInfo.hardwareVersion = '';
						that.deviceInfo.manufacturer = '';
						that.deviceInfo.batteryLevel = '';
						
						// 清除本地存储的连接状态
						that.clearConnectedDeviceStorage();
						
						// 移除监听器
						uni.offBLECharacteristicValueChange();
						that.characteristicListenerSet = false;
						// 停止连接监控
						that.stopConnectionMonitor();
					}

					uni.showToast({
						title: '已断开连接',
						icon: 'success'
					});
				},
				fail: (err) => {
					console.error('断开设备连接失败', err);

					uni.showToast({
						title: '断开失败',
						icon: 'none'
					});
				}
			});
		},

			// 断开所有设备连接
		disconnectAllDevices() {
			console.log('断开所有设备连接');
			const that = this;

			// 遍历所有已连接的设备并断开连接
			that.discoveredDevices.forEach(device => {
				if (device.connected) {
					that.disconnectDevice(device);
				}
			});
		},

		// 移除设备
		removeDevice(device) {
			console.log('移除设备', device);
			const that = this;

			// 如果设备已连接，先断开连接
			if (device.connected) {
				that.disconnectDevice(device);
			}

			// 从设备列表中移除
			const index = that.discoveredDevices.findIndex(d => d.deviceId === device.deviceId);
			if (index !== -1) {
				that.discoveredDevices.splice(index, 1);
			}

			// 如果移除的是当前连接的设备，重置状态
			if (that.connectedDeviceId === device.deviceId) {
				that.connectedDeviceId = '';
				that.deviceName = '智能骑行传感器 A1';
				that.deviceStatus = '已移除';
			}

			uni.showToast({
				title: '已移除设备',
				icon: 'success'
			});
		},

			// 获取蓝牙设备服务
		getBLEDeviceServices(deviceId) {
			console.log('获取设备服务', deviceId);
			const that = this;

			// 清空之前的服务和特征值数据
			that.bleServices = {};
			that.bleCharacteristics = {};

			uni.getBLEDeviceServices({
				deviceId: deviceId,
				success: (res) => {
					console.log('获取设备服务成功', res);

					// 遍历所有服务
					res.services.forEach(service => {
						console.log('服务UUID:', service.uuid);
						// 保存服务信息
						that.bleServices[service.uuid] = service;

						// 获取服务特征值
						that.getBLEDeviceCharacteristics(deviceId, service.uuid);
					});
					
					// 如果是设备信息服务(0x180A)，尝试读取设备信息
					if (that.bleServices['0x180a'] || that.bleServices['180a']) {
						console.log('找到设备信息服务，尝试读取设备信息');
						// 延迟一下，确保特征值已经获取
						setTimeout(() => {
							that.readDeviceInformation(deviceId);
						}, 500);
					}
					
					// 如果是电池服务(0x180F)，尝试读取电池电量
					if (that.bleServices['0x180f'] || that.bleServices['180f']) {
						console.log('找到电池服务，尝试读取电池电量');
						// 延迟一下，确保特征值已经获取
						setTimeout(() => {
							that.readBatteryLevel(deviceId);
						}, 500);
					}
				},
				fail: (err) => {
					console.error('获取设备服务失败', err);
				}
			});
		},
			
			// 读取设备信息
		readDeviceInformation(deviceId) {
			console.log('尝试读取设备信息', deviceId);
			
			// UUID标准化函数
			const normalizeUUID = (uuid) => {
				// 移除可能的前缀
				let normalized = uuid.toLowerCase().replace(/^0x|^0X/g, '');
				// 移除可能的连字符
				normalized = normalized.replace(/-/g, '');
				return normalized;
			};
			
			// 查找设备信息服务，使用标准化的UUID进行匹配
			let serviceId = null;
			const serviceKeys = Object.keys(this.bleServices);
			console.log('已发现的服务列表:', serviceKeys);
			
			for (const key of serviceKeys) {
				const normalizedKey = normalizeUUID(key);
				console.log(`检查服务: ${key} (normalized: ${normalizedKey})`);
				if (normalizedKey === '180a') {
					serviceId = key;
					console.log('找到设备信息服务:', serviceId);
					break;
				}
			}
			
			if (serviceId && this.bleCharacteristics[serviceId]) {
				console.log('设备信息服务的特征值列表:', Object.keys(this.bleCharacteristics[serviceId]));
				// 尝试读取各种设备信息
				const characteristicsToRead = [
					{ id: '2a24', key: 'model', name: '设备型号' },
					{ id: '2a25', key: 'serialNumber', name: '序列号' },
					{ id: '2a26', key: 'firmwareVersion', name: '固件版本' },
					{ id: '2a27', key: 'hardwareVersion', name: '硬件版本' },
					{ id: '2a28', key: 'softwareVersion', name: '软件版本' },
					{ id: '2a29', key: 'manufacturer', name: '制造商' }
				];
				
				let readIndex = 0;
				const readNextCharacteristic = () => {
					if (readIndex >= characteristicsToRead.length) {
						console.log('设备信息读取完成');
						return; // 所有特征值都已尝试读取
					}
					
					const { id, key, name } = characteristicsToRead[readIndex];
					let charId = null;
					
					// 查找特征值，使用标准化的UUID进行匹配
					const charKeys = Object.keys(this.bleCharacteristics[serviceId]);
					for (const charKey of charKeys) {
						const normalizedCharKey = normalizeUUID(charKey);
						console.log(`检查特征值: ${charKey} (normalized: ${normalizedCharKey})，寻找: ${id}`);
						if (normalizedCharKey === id) {
							charId = charKey;
							console.log(`找到${name}特征值: ${charId}`);
							break;
						}
					}
					
					if (charId) {
						const char = this.bleCharacteristics[serviceId][charId];
						
						// 检查是否有读取权限
						if (char.properties.read) {
							console.log(`尝试读取${name}: ${serviceId}/${charId}`);
							// 延迟读取，避免API调用过于频繁
							setTimeout(() => {
								this.readDeviceCharacteristicValue(deviceId, serviceId, charId);
								readIndex++;
								readNextCharacteristic();
							}, 200);
						} else {
							console.log(`${name}特征值不支持读取`);
							// 尝试启用通知（如果支持）
							if (char.properties.notify || char.properties.indicate) {
								console.log(`尝试启用${name}特征值通知`);
								setTimeout(() => {
									this.notifyBLECharacteristicValueChange(deviceId, serviceId, charId);
									readIndex++;
									readNextCharacteristic();
								}, 200);
							} else {
								readIndex++;
								readNextCharacteristic();
							}
						}
					} else {
						console.log(`${name}特征值未找到 (寻找标准化的: ${id})`);
						readIndex++;
						readNextCharacteristic();
					}
				};
				
				// 开始按顺序读取特征值
				readNextCharacteristic();
			} else {
				console.log('未找到设备信息服务或特征值');
				// 如果没有找到设备信息服务，尝试直接读取（可能服务UUID格式不同）
				this.directReadDeviceInfo(deviceId);
			}
		},
			
			// 读取电池电量
			readBatteryLevel(deviceId) {
				console.log('尝试读取电池电量', deviceId);
				const serviceId = this.bleServices['0x180f'] ? '0x180f' : '180f';
				const characteristicId = '0x2a19';
				
				if (serviceId && this.bleCharacteristics[serviceId] && 
					(this.bleCharacteristics[serviceId][characteristicId] || 
					 this.bleCharacteristics[serviceId][characteristicId.replace('0x', '')])) {
					const charId = this.bleCharacteristics[serviceId][characteristicId] ? 
						characteristicId : characteristicId.replace('0x', '');
					const char = this.bleCharacteristics[serviceId][charId];
					
					// 检查是否有读取权限
					if (char.properties.read) {
						console.log('尝试读取电池电量');
						this.readDeviceCharacteristicValue(deviceId, serviceId, charId);
					} else if (char.properties.notify) {
						console.log('电池电量特征值支持通知，设置通知');
						this.notifyBLECharacteristicValueChange(deviceId, serviceId, charId);
					}
				}
			},

			// 获取蓝牙设备特征值
		getBLEDeviceCharacteristics(deviceId, serviceId) {
			console.log('获取设备特征值', deviceId, serviceId);

			// 初始化该服务的特征值对象
			if (!this.bleCharacteristics[serviceId]) {
				this.bleCharacteristics[serviceId] = {};
			}
			
			// 设置特征值监听器（如果还没有设置）
			if (!this.characteristicListenerSet) {
				this.setupCharacteristicListener();
			}

				uni.getBLEDeviceCharacteristics({
					deviceId: deviceId,
					serviceId: serviceId,
					success: (res) => {
						console.log('获取设备特征值成功', res);

						// 遍历所有特征值
						res.characteristics.forEach(characteristic => {
							console.log('特征值UUID:', characteristic.uuid);
							
							// 保存特征值信息
							this.bleCharacteristics[serviceId][characteristic.uuid] = characteristic;

							// 如果特征值支持通知或指示，则启用通知
							if (characteristic.properties.notify || characteristic.properties.indicate) {
								this.notifyBLECharacteristicValueChange(deviceId, serviceId, characteristic.uuid);
							}
							
							// 如果特征值支持读取，则读取设备信息
							if (characteristic.properties.read) {
								// 延迟读取，确保通知已正确设置
								setTimeout(() => {
									this.readDeviceCharacteristicValue(deviceId, serviceId, characteristic.uuid);
								}, 200);
							}
						});
					},
					fail: (err) => {
						console.error('获取设备特征值失败', err);
					},
				});
			},

			// 启用蓝牙设备特征值变化通知
			notifyBLECharacteristicValueChange(deviceId, serviceId, characteristicId) {
				console.log('启用蓝牙设备特征值变化通知', deviceId, serviceId, characteristicId);

				// 移除之前的监听器，避免重复监听
				uni.offBLECharacteristicValueChange();

				// 先监听特征值变化
				uni.onBLECharacteristicValueChange((res) => {
					console.log('特征值变化', res);
					// 确保是当前连接的设备
					if (res.deviceId === this.connectedDeviceId) {
						// 处理接收到的数据
						this.handleCharacteristicValueChange(res);
					}
				});

				// 然后启用通知
				uni.notifyBLECharacteristicValueChange({
					deviceId: deviceId,
					serviceId: serviceId,
					characteristicId: characteristicId,
					state: true,
					success: (res) => {
						console.log('启用蓝牙设备特征值变化通知成功', res);
					},
					fail: (err) => {
						console.error('启用蓝牙设备特征值变化通知失败', err);
					}
				});
			},

			// 处理接收到的数据
			handleReceivedData(buffer) {
				// 将ArrayBuffer转换为字符串
				const str = this.ab2hex(buffer);
				console.log('接收到的数据:', str);

				// 这里可以根据实际协议解析数据
				// 例如：解析传感器数据、控制命令等
			},


			// ArrayBuffer转16进制字符串
			ab2hex(buffer) {
				const hexArr = Array.prototype.map.call(
					new Uint8Array(buffer),
					function (bit) {
						return ('00' + bit.toString(16)).slice(-2)
					}
				)
				return hexArr.join('');
			},

			// 读取设备特征值数据
			readDeviceCharacteristicValue(deviceId, serviceId, characteristicId) {
				console.log('读取设备特征值数据', deviceId, serviceId, characteristicId);

				uni.readBLECharacteristicValue({
					deviceId: deviceId,
					serviceId: serviceId,
					characteristicId: characteristicId,
					success: (res) => {
						console.log('读取特征值成功', res);
						// 读取操作成功后，需要等待onBLECharacteristicValueChange回调获取数据
					},
					fail: (err) => {
						console.error('读取特征值失败', err);
					}
				});
			},

			// 监听特征值变化
			setupCharacteristicListener() {
				console.log('设置特征值监听器');
				// 先移除可能存在的旧监听器
				uni.offBLECharacteristicValueChange();
				
				// 设置新的监听器
				uni.onBLECharacteristicValueChange(this.handleCharacteristicValueChange.bind(this));
				this.characteristicListenerSet = true;
				console.log('特征值监听器设置完成');
			},
			
			// 直接读取设备信息（备用方法）
			directReadDeviceInfo(deviceId) {
				console.log('尝试直接读取设备信息');
				// UUID标准化函数
				const normalizeUUID = (uuid) => {
					// 移除可能的前缀
					let normalized = uuid.toLowerCase().replace(/^0x|^0X/g, '');
					// 移除可能的连字符
					normalized = normalized.replace(/-/g, '');
					return normalized;
				};
				
				// 尝试直接使用标准UUID读取设备信息，不依赖于服务发现
				const serviceIds = ['0x180a', '180a', '0X180A', '0000180a-0000-1000-8000-00805f9b34fb'];
				const characteristics = [
					{ id: '0x2a24', altIds: ['2a24', '00002a24-0000-1000-8000-00805f9b34fb'], key: 'model', name: '设备型号' },
					{ id: '0x2a25', altIds: ['2a25', '00002a25-0000-1000-8000-00805f9b34fb'], key: 'serialNumber', name: '序列号' },
					{ id: '0x2a26', altIds: ['2a26', '00002a26-0000-1000-8000-00805f9b34fb'], key: 'firmwareVersion', name: '固件版本' },
					{ id: '0x2a27', altIds: ['2a27', '00002a27-0000-1000-8000-00805f9b34fb'], key: 'hardwareVersion', name: '硬件版本' },
					{ id: '0x2a28', altIds: ['2a28', '00002a28-0000-1000-8000-00805f9b34fb'], key: 'softwareVersion', name: '软件版本' },
					{ id: '0x2a29', altIds: ['2a29', '00002a29-0000-1000-8000-00805f9b34fb'], key: 'manufacturer', name: '制造商' }
				];
				
				let serviceIndex = 0;
				let charIndex = 0;
				let charIdIndex = 0;
				
				const tryReadCharacteristic = () => {
					if (serviceIndex >= serviceIds.length) {
						console.log('直接读取设备信息完成');
						return;
					}
					
					if (charIndex >= characteristics.length) {
						// 尝试下一个服务
						serviceIndex++;
						charIndex = 0;
						charIdIndex = 0;
						tryReadCharacteristic();
						return;
					}
					
					const serviceId = serviceIds[serviceIndex];
					const { id, altIds, key, name } = characteristics[charIndex];
					
					// 获取当前要尝试的特征值ID
					const allCharIds = [id, ...altIds];
					if (charIdIndex >= allCharIds.length) {
						// 当前特征值的所有ID都尝试过了，尝试下一个特征值
						charIndex++;
						charIdIndex = 0;
						tryReadCharacteristic();
						return;
					}
					
					const characteristicId = allCharIds[charIdIndex];
					
					console.log(`尝试直接读取 ${name}: ${serviceId}/${characteristicId}`);
					
					uni.readBLECharacteristicValue({
						deviceId: deviceId,
					serviceId: serviceId,
					characteristicId: characteristicId,
					success: (res) => {
						console.log(`直接读取${name}成功，等待数据回调`, res);
						// 读取成功后，继续尝试下一个特征值
						charIndex++;
						charIdIndex = 0;
						setTimeout(tryReadCharacteristic, 300);
					},
					fail: (err) => {
						console.log(`直接读取${name}失败 (${serviceId}/${characteristicId}):`, err);
						// 尝试当前特征值的下一个ID格式
						charIdIndex++;
						setTimeout(tryReadCharacteristic, 100);
					}
					});
				};
				
				// 开始尝试读取
				tryReadCharacteristic();
			},
			
			// 处理特征值变化
		handleCharacteristicValueChange(res) {
			console.log('特征值变化', res);
			const { deviceId, serviceId, characteristicId, value } = res;

			// 确保是当前连接的设备
			if (deviceId !== this.connectedDeviceId) {
				console.log('忽略非当前连接设备的数据');
				return;
			}

			// 将ArrayBuffer转换为16进制字符串
			const hexString = this.ab2hex(value);
			// 将ArrayBuffer转换为字符串
			const strValue = this.ab2str(value);

			// 标准化UUID格式（移除前缀并转为小写）
			const normalizeUUID = (uuid) => {
				// 移除可能的前缀
				let normalized = uuid.toLowerCase().replace(/^0x|^0X/g, '');
				// 移除可能的连字符
				normalized = normalized.replace(/-/g, '');
				return normalized;
			};

			const normalizedServiceId = normalizeUUID(serviceId);
			const normalizedCharId = normalizeUUID(characteristicId);

			console.log(`Service: ${serviceId} (normalized: ${normalizedServiceId}), Characteristic: ${characteristicId} (normalized: ${normalizedCharId}), Value: ${hexString}, String: "${strValue}"`);

			// 确保设备信息区域显示
			if (!this.deviceInfo.show) {
				this.deviceInfo.show = true;
				console.log('设置deviceInfo.show为true');
			}

			// 处理电池电量
			if (normalizedServiceId === '180f') {
				if (normalizedCharId === '2a19') {
					try {
						// 电池电量是一个字节的数值 (0-100)
						const batteryLevel = new Uint8Array(value)[0];
						this.deviceInfo.batteryLevel = `${batteryLevel}%`;
						console.log('电池电量:', this.deviceInfo.batteryLevel);
					} catch (error) {
						console.error('解析电池电量失败:', error);
					}
				}
			}

			// 处理设备信息
			if (normalizedServiceId === '180a') {
				console.log('检测到设备信息服务(180a)，处理特征值:', normalizedCharId);
				switch (normalizedCharId) {
					case '2a24': // Model
						console.log('检测到设备型号特征值(2a24)，原始值:', strValue);
						if (strValue && strValue.trim()) {
							this.deviceInfo.model = strValue.trim();
							console.log('更新设备型号为:', this.deviceInfo.model);
						} else {
							console.log('设备型号值为空或只有空白字符');
						}
						break;
					case '2a25': // Serial Number
						console.log('检测到序列号特征值(2a25)，原始值:', strValue);
						if (strValue && strValue.trim()) {
							this.deviceInfo.serialNumber = strValue.trim();
							console.log('更新序列号为:', this.deviceInfo.serialNumber);
						} else {
							console.log('序列号值为空或只有空白字符');
						}
						break;
					case '2a26': // Firmware Version
						console.log('检测到固件版本特征值(2a26)，原始值:', strValue);
						if (strValue && strValue.trim()) {
							this.deviceInfo.firmwareVersion = strValue.trim();
							console.log('更新固件版本为:', this.deviceInfo.firmwareVersion);
						} else {
							console.log('固件版本值为空或只有空白字符');
						}
						break;
					case '2a27': // Hardware Version
						console.log('检测到硬件版本特征值(2a27)，原始值:', strValue);
						if (strValue && strValue.trim()) {
							this.deviceInfo.hardwareVersion = strValue.trim();
							console.log('更新硬件版本为:', this.deviceInfo.hardwareVersion);
						} else {
							console.log('硬件版本值为空或只有空白字符');
						}
						break;
					case '2a28': // Software Version
						console.log('检测到软件版本特征值(2a28)，原始值:', strValue);
						if (strValue && strValue.trim()) {
							this.deviceInfo.softwareVersion = strValue.trim();
							console.log('更新软件版本为:', this.deviceInfo.softwareVersion);
						} else {
							console.log('软件版本值为空或只有空白字符');
						}
						break;
					case '2a29': // Manufacturer Name
						console.log('检测到制造商特征值(2a29)，原始值:', strValue);
						if (strValue && strValue.trim()) {
							this.deviceInfo.manufacturer = strValue.trim();
							console.log('更新制造商为:', this.deviceInfo.manufacturer);
						} else {
							console.log('制造商值为空或只有空白字符');
						}
						break;
					default:
						console.log('未识别的设备信息特征值:', normalizedCharId);
				}
			}
			
			// 立即强制更新设备名称
			if (this.deviceName === '智能骑行传感器 A1' && strValue && strValue.trim()) {
				// 尝试从设备信息中获取设备名称
				if (normalizedCharId === '2a24' || normalizedCharId === '2a29') {
					this.deviceName = strValue.trim();
					console.log('更新设备名称为:', this.deviceName);
				}
			}
			
			// 记录deviceInfo当前状态
			console.log('deviceInfo当前状态:', JSON.stringify(this.deviceInfo));
			
			// 强制更新UI，确保用户能看到最新状态
			this.$forceUpdate();
			console.log('强制更新UI后');
		},

			// ArrayBuffer转字符串
			ab2str(buffer) {
				try {
					// 直接使用String.fromCharCode实现，确保在所有环境中都能正常工作
					const uint8Array = new Uint8Array(buffer);
					let result = String.fromCharCode.apply(null, uint8Array);
					// 移除可能的空字符和控制字符
					result = result.replace(/[\x00-\x1F\x7F]/g, '');
					return result;
				} catch (error) {
					console.error('字符串转换失败:', error);
					// 最终备用方案
					return '';
				}
			},

			// 切换标签页
			switchTab(tab) {
				this.activeTab = tab;
				console.log('切换到标签页:', tab);
				// 这里可以添加切换标签页的逻辑
				if (tab === 'riding') {
					// 跳转到骑行页面
					uni.switchTab({
						url: '/pages/index/index'
					});
				}
			},
		}
</script>

<style>
	.container {
		display: flex;
		flex-direction: column;
		height: 100vh;
		padding: 10px;
		background-color: #f5f5f5;
	}

	/* 顶部数据区域样式 */
	.data-section {
		background-color: #ffffff;
		border-radius: 10px;
		padding: 10px;
		/* 减小内边距 */
		margin-bottom: 10px;
		box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
		height: 200px;
		/* 固定高度，减小一半左右 */
	}

	.section-title {
		font-size: 16px;
		/* 减小字体大小 */
		font-weight: bold;
		margin-bottom: 5px;
		/* 减小下边距 */
		color: #333;
	}

	.data-list {
		background-color: #f9f9f9;
		border-radius: 8px;
		overflow: hidden;
		height: calc(100% - 25px);
		/* 计算剩余高度 */
	}

	.data-list-item {
		display: flex;
		justify-content: space-between;
		padding: 8px 10px;
		/* 减小内边距 */
		border-bottom: 1px solid #eee;
	}

	.data-list-item:last-child {
		border-bottom: none;
	}

	.data-list-label {
		font-size: 14px;
		/* 减小字体大小 */
		color: #666;
	}

	.data-list-value {
		font-size: 14px;
		/* 减小字体大小 */
		font-weight: bold;
		color: #333;
	}

	/* 中间历史骑行数据区域样式 */
	.history-section {
		flex: 1;
		background-color: #ffffff;
		border-radius: 10px;
		padding: 15px;
		margin-bottom: 10px;
		box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
		display: flex;
		flex-direction: column;
	}

	.history-list {
		flex: 1;
		overflow-y: auto;
	}

	.history-item {
		display: flex;
		flex-direction: column;
		padding: 15px;
		border-bottom: 1px solid #eee;
	}

	.history-item:last-child {
		border-bottom: none;
	}

	.history-date {
		margin-bottom: 8px;
	}

	.date-text {
		font-size: 16px;
		font-weight: bold;
		color: #333;
	}

	.history-details {
		display: flex;
		justify-content: space-between;
	}

	.time-text {
		font-size: 14px;
		color: #666;
	}

	.location-text {
		font-size: 14px;
		color: #666;
	}

	/* 底部设备区域样式 */
	.device-area {
			background-color: #ffffff;
			border-radius: 10px;
			padding: 15px;
			margin-bottom: 10px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
		}
		
		/* 设备信息显示区域样式 */
		.device-info-section {
			background-color: #f8f8f8;
			border-radius: 8px;
			padding: 10px;
			margin: 10px 0;
			border: 1px solid #e0e0e0;
		}
		
		.device-info-item {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 8px 0;
			border-bottom: 1px solid #f0f0f0;
		}
		
		.device-info-item:last-child {
			border-bottom: none;
		}
		
		.device-info-label {
			font-size: 14px;
			color: #666666;
		}
		
		.device-info-value {
			font-size: 14px;
			color: #333333;
			font-weight: 500;
		}
		
		.device-info-value.battery {
				color: #07c160;
				font-weight: bold;
			}
			
			.device-info-value.connected {
				color: #07c160;
				font-weight: bold;
			}
			
			.device-info-value.disconnected {
				color: #ff4d4f;
				font-weight: bold;
			}

	.device-container {
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 20px 0;
	}

	.device-box {
		width: 200px;
		height: 120px;
		background-color: #f0f0f0;
		border: 2px dashed #ccc;
		border-radius: 8px;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		position: relative;
	}

	.device-name {
		font-size: 16px;
		font-weight: bold;
		color: #333;
		margin-bottom: 8px;
	}

	.device-status {
		font-size: 14px;
		color: #FF5722;
	}

	.search-hint {
		font-size: 12px;
		color: #FF5722;
		margin-top: 5px;
	}

	.device-list {
		margin-top: 15px;
		border-top: 1px solid #eee;
		padding-top: 15px;
	}

	.device-list-item {
		display: flex;
		flex-direction: column;
		padding: 15px;
		border-bottom: 1px solid #eee;
		background-color: #f9f9f9;
		border-radius: 8px;
		margin-bottom: 10px;
	}

	.device-list-item:last-child {
		border-bottom: none;
		margin-bottom: 0;
	}

	.device-item-name {
		font-size: 16px;
		font-weight: bold;
		color: #333;
		margin-bottom: 5px;
	}

	.device-item-signal {
		font-size: 12px;
		color: #666;
		margin-bottom: 10px;
	}

	.device-item-actions {
		display: flex;
		justify-content: flex-end;
		gap: 10px;
	}

	.action-button {
		padding: 5px 10px;
		background-color: #f0f0f0;
		border-radius: 4px;
		font-size: 12px;
		color: #333;
	}

	.action-button:active {
		background-color: #e0e0e0;
	}




</style>